# 应用问题解决-缓存穿透

## 一、问题描述
**key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。**
![](https://raw.gitmirror.com/KwFruit/basic-picture-service/note-v1.0.0/img/202308281050175.png)
**解释**

#### 1、redis查询不到数据了，造成大面积的未命中
  比如出现很多为空的查询，而这些为空的查询没有进行缓存，此时请求就会大面积的打到数据库。
#### 2、出现很多非正常的url访问（其实还是查出空数据）
 什么是非正常的url，比如正常的是 /getBook/1    得到id为1 的book数据，非正常的 /getBook/a 或者 /getBook/1000000   id数据库里面没有，也就是说还是查的空数据，此时redis没有将空数据缓存，大量请求就会打到数据库，从而将其压垮。

**解决方案**
一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。
解决方案：
**（1） 对空值缓存：**如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟
**（2） 设置可访问的名单（白名单）：**
使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。
**（3） 采用布隆过滤器**：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。
布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)
将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。
**（4） 进行实时监控：**当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务
