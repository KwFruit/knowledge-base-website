---
title: Spring高级-BeanFactory实现的特点
date: 2023-08-20 10:42:08
permalink: /pages/ca80e7/
categories:
  - Java
  - Spring高级
tags:
  - 
---

## 一、DefaultListableBeanFactory
 DefaultListableBeanFactory，是 BeanFactory 最重要的实现，像**控制反转**和**依赖注入**功能，都是它来实现

### 1、需求一：往DefaultListableBeanFactory里面 注册一个组件
```java
package com.mangoubiubiu.show;

import lombok.extern.slf4j.Slf4j;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.logging.Logger;

public class 
{

    public static void main(String[] args) {

        DefaultListableBeanFactory beanFactory=new DefaultListableBeanFactory();

        //bean 的定义 （class  ,scope , 初始化 ，销毁方法）

        AbstractBeanDefinition beanDefinition
                = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope("singleton").getBeanDefinition();
        beanFactory.registerBeanDefinition("config",beanDefinition);


        for(String name  : beanFactory.getBeanDefinitionNames()){
            System.out.println(name);
        }

    }



    @Configuration
    static class Config{
        @Bean
        public Bean1 bean1(){
            return new Bean1();
        }
        @Bean
        public Bean2 bean2(){
            return new Bean2();
        }
    }

    @Slf4j
    static class Bean1{
        public Bean1(){
            log.info("构造 Bean1");
        }

        @Autowired
        private Bean2 bean2;

        public Bean2 getBean2(){
            return bean2;
        }
    }


    @Slf4j
    static class Bean2{
        public Bean2(){
            log.info("构造 Bean2");
        }

    }







}

```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2659116/1648647729392-34f5bfd1-6d9a-46e6-abe8-4c7ee73c3b3c.png#clientId=u9fdf2578-3a15-4&from=paste&height=113&id=uc714928d&originHeight=151&originWidth=985&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11806&status=done&style=none&taskId=uf1a2416e-7655-47fd-86c5-2c927f4a2da&title=&width=738.749977983535)
问题：发现仅仅confi注册进来了，config里面的bean没有注册进来
### 2、解决Config里面的组件注册不进来的问题：为BeanFactory添加一些常用的后处理器，对BeanFactory 做增强处理，来将Config里面的组件也注册在BeanFactory里面
```java
package com.mangoubiubiu.show;

import lombok.extern.slf4j.Slf4j;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.logging.Logger;

public class TestBeanFactory {

    public static void main(String[] args) {

        DefaultListableBeanFactory beanFactory=new DefaultListableBeanFactory();

        //bean 的定义 （class  ,scope , 初始化 ，销毁方法）

        AbstractBeanDefinition beanDefinition
                = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope("singleton").getBeanDefinition();
        beanFactory.registerBeanDefinition("config",beanDefinition);

        //给 BeanFactory 添加一些常用的后处理器
        AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);


        //BeanFactory 后处理器主要功能，补充了一些bean的定义　BeanFactoryPostProcessor把所有Ｂean工厂的后处理器拿到，逐一执行做扩展
       beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().stream().forEach(beanFactoryPostProcessor -> {
           beanFactoryPostProcessor.postProcessBeanFactory(beanFactory);
       });

        for(String name  : beanFactory.getBeanDefinitionNames()){
            System.out.println(name);
        }
        
        Bean1 bean = beanFactory.getBean(Bean1.class);
        System.out.println(bean.getBean2());

    }

    
    @Configuration
    static class Config{
        @Bean
        public Bean1 bean1(){
            return new Bean1();
        }
        @Bean
        public Bean2 bean2(){
            return new Bean2();
        }
    }

    @Slf4j
    static class Bean1{
        public Bean1(){
            log.info("构造 Bean1");
        }

        @Autowired
        private Bean2 bean2;

        public Bean2 getBean2(){
            return bean2;
        }
    }

    @Slf4j
    static class Bean2{
        public Bean2(){
            log.info("构造 Bean2");
        }

    }

}

```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/2659116/1648648900694-e7a7f34c-4acb-4c9f-8858-86c9da54b1b3.png#clientId=u9fdf2578-3a15-4&from=paste&height=625&id=u876cec72&originHeight=833&originWidth=1014&originalType=binary&ratio=1&rotation=0&showTitle=false&size=125931&status=done&style=none&taskId=ue0e39890-7c31-48ec-865f-6a9f6d05185&title=&width=760.4999773353345)
![image.png](https://cdn.nlark.com/yuque/0/2022/png/2659116/1648648923720-95ca4248-9456-4cc6-91ae-c424f4ee02b1.png#clientId=u9fdf2578-3a15-4&from=paste&height=501&id=uaf2c5816&originHeight=668&originWidth=555&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43109&status=done&style=none&taskId=u4cc67c3c-bdfb-496b-80c7-188bd8e395d&title=&width=416.2499875947837)
相关Processor作用
org.springframework.context.annotation.internalConfigurationAnnotationProcessor  处理Configuration注解
org.springframework.context.annotation.internalAutowiredAnnotationProcessor 完成对象属性的注入
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
### 3、解决依赖注入不到的问题：添加一些Bean的后处理器_针对 bean 的生命周期的各个阶段提供扩展，例如@Autowired @Resource_
```java
package com.mangoubiubiu.show;

import lombok.extern.slf4j.Slf4j;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.logging.Logger;

public class TestBeanFactory {

    public static void main(String[] args) {

        DefaultListableBeanFactory beanFactory=new DefaultListableBeanFactory();

        //bean 的定义 （class  ,scope , 初始化 ，销毁方法）

        AbstractBeanDefinition beanDefinition
                = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope("singleton").getBeanDefinition();
        beanFactory.registerBeanDefinition("config",beanDefinition);

        //给 BeanFactory 添加一些常用的后处理器
        AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);


        //BeanFactory 后处理器主要功能，补充了一些bean的定义
       beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().stream().forEach(beanFactoryPostProcessor -> {
           beanFactoryPostProcessor.postProcessBeanFactory(beanFactory);
       });

       //Bean后处理器，针对 bean 的生命周期的各个阶段提供扩展，例如@Autowired @Resource
      //  beanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(beanFactory::addBeanPostProcessor);
        beanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(beanPostProcessor -> {
            beanFactory.addBeanPostProcessor(beanPostProcessor);//建立bean工厂与后处理器之间的联系
        });

        for(String name  : beanFactory.getBeanDefinitionNames()){
            System.out.println(name);
        }
        System.out.println("----------------->");

        Bean1 bean = beanFactory.getBean(Bean1.class);
        System.out.println("成功取到Bean2的对象:"+bean.getBean2());
        /**
         * 学到了什么：
         * a. beanFactory 不会做的事
         *   1 。不会主动调用BeanFactory 后处理器
         *   2. 不会主动添加Bean后处理器
         *   3. 不会主动初始化单列
         *   4. 不会解析beanFactory 还不会解析 ${} 与 #{}
         *
         * b. bean 后处理器会有排序逻辑
         */
    }



    @Configuration
    static class Config{
        @Bean
        public Bean1 bean1(){
            return new Bean1();
        }
        @Bean
        public Bean2 bean2(){
            return new Bean2();
        }
    }

    @Slf4j
    static class Bean1{
        public Bean1(){
            log.info("构造 Bean1");
        }

        @Autowired
        private Bean2 bean2;

        public Bean2 getBean2(){
            return bean2;
        }
    }


    @Slf4j
    static class Bean2{
        public Bean2(){
            log.info("构造 Bean2");
        }

    }







}

```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/2659116/1648649278003-59d03591-7ea1-4207-a3a7-75cb53cdbf9f.png#clientId=u9fdf2578-3a15-4&from=paste&height=880&id=u45248b21&originHeight=1174&originWidth=1056&originalType=binary&ratio=1&rotation=0&showTitle=false&size=217568&status=done&style=none&taskId=u690764ab-bb09-48a5-8dfe-8850fd6ad1e&title=&width=791.9999763965614)
### 4、利用beanFactory.preInstantiateSingletons()创建所有的单列对象
![image.png](https://cdn.nlark.com/yuque/0/2022/png/2659116/1648649464664-529cabd2-1bb7-4647-813f-c8d7efd78e4b.png#clientId=u9fdf2578-3a15-4&from=paste&height=760&id=u25291472&originHeight=1013&originWidth=936&originalType=binary&ratio=1&rotation=0&showTitle=false&size=172225&status=done&style=none&taskId=u1c552a12-f3ca-4e18-aeb0-77df1d6a787&title=&width=701.9999790787703)
### 5、总结

- **a. beanFactory 不会做的事**
*   1. 不会主动调用BeanFactory 后处理器
*   2. 不会主动添加Bean后处理器
*   3. 不会主动初始化单列
*   4. 不会解析beanFactory 还不会解析 ${} 与 #{}
